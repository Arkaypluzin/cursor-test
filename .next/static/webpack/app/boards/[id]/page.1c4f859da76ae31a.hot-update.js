"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/boards/[id]/page",{

/***/ "(app-pages-browser)/./lib/hooks/useLists.ts":
/*!*******************************!*\
  !*** ./lib/hooks/useLists.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLists: function() { return /* binding */ useLists; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase/client */ \"(app-pages-browser)/./lib/supabase/client.ts\");\n/* __next_internal_client_entry_do_not_use__ useLists auto */ \n\nfunction useLists(boardId) {\n    const [lists, setLists] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const supabase = (0,_lib_supabase_client__WEBPACK_IMPORTED_MODULE_1__.createClient)();\n    const fetchLists = async ()=>{\n        if (!boardId) {\n            setLists([]);\n            setLoading(false);\n            return;\n        }\n        try {\n            setLoading(true);\n            const { data, error: fetchError } = await supabase.from(\"lists\").select(\"*\").eq(\"board_id\", boardId).order(\"order_index\", {\n                ascending: true\n            });\n            if (fetchError) throw fetchError;\n            setLists(data || []);\n            setError(null);\n        } catch (err) {\n            setError(err.message || \"Failed to fetch lists\");\n            console.error(\"Error fetching lists:\", err);\n        } finally{\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchLists();\n        if (!boardId) return;\n        // Subscribe to realtime changes for lists in this board\n        const channel = supabase.channel(\"lists-changes-\".concat(boardId)).on(\"postgres_changes\", {\n            event: \"*\",\n            schema: \"public\",\n            table: \"lists\",\n            filter: \"board_id=eq.\".concat(boardId)\n        }, (payload)=>{\n            if (payload.eventType === \"INSERT\") {\n                setLists((prev)=>{\n                    const exists = prev.find((l)=>l.id === payload.new.id);\n                    if (exists) return prev;\n                    return [\n                        ...prev,\n                        payload.new\n                    ].sort((a, b)=>a.order_index - b.order_index);\n                });\n            } else if (payload.eventType === \"UPDATE\") {\n                setLists((prev)=>prev.map((list)=>list.id === payload.new.id ? payload.new : list).sort((a, b)=>a.order_index - b.order_index));\n            } else if (payload.eventType === \"DELETE\") {\n                setLists((prev)=>prev.filter((list)=>list.id !== payload.old.id));\n            }\n        }).subscribe();\n        return ()=>{\n            supabase.removeChannel(channel);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        boardId\n    ]);\n    const createList = async (title)=>{\n        if (!boardId) return {\n            data: null,\n            error: \"No board selected\"\n        };\n        try {\n            // Get the max order_index for this board\n            const { data: existingLists } = await supabase.from(\"lists\").select(\"order_index\").eq(\"board_id\", boardId).order(\"order_index\", {\n                ascending: false\n            }).limit(1);\n            const maxOrder = existingLists && existingLists.length > 0 ? existingLists[0].order_index + 1 : 0;\n            const { data, error: createError } = await supabase.from(\"lists\").insert([\n                {\n                    title,\n                    board_id: boardId,\n                    order_index: maxOrder\n                }\n            ]).select().single();\n            if (createError) throw createError;\n            setLists((prev)=>[\n                    ...prev,\n                    data\n                ].sort((a, b)=>a.order_index - b.order_index));\n            return {\n                data,\n                error: null\n            };\n        } catch (err) {\n            const errorMsg = err.message || \"Failed to create list\";\n            setError(errorMsg);\n            return {\n                data: null,\n                error: errorMsg\n            };\n        }\n    };\n    const updateList = async (id, updates)=>{\n        try {\n            const { error: updateError } = await supabase.from(\"lists\").update(updates).eq(\"id\", id);\n            if (updateError) throw updateError;\n            setLists((prev)=>prev.map((list)=>list.id === id ? {\n                        ...list,\n                        ...updates\n                    } : list));\n            return {\n                error: null\n            };\n        } catch (err) {\n            const errorMsg = err.message || \"Failed to update list\";\n            setError(errorMsg);\n            return {\n                error: errorMsg\n            };\n        }\n    };\n    const deleteList = async (id)=>{\n        try {\n            const { error: deleteError } = await supabase.from(\"lists\").delete().eq(\"id\", id);\n            if (deleteError) throw deleteError;\n            setLists((prev)=>prev.filter((list)=>list.id !== id));\n            return {\n                error: null\n            };\n        } catch (err) {\n            const errorMsg = err.message || \"Failed to delete list\";\n            setError(errorMsg);\n            return {\n                error: errorMsg\n            };\n        }\n    };\n    const reorderLists = async (newOrder)=>{\n        try {\n            // Update all lists in a transaction-like manner\n            const updates = newOrder.map((param)=>{\n                let { id, order_index } = param;\n                return supabase.from(\"lists\").update({\n                    order_index\n                }).eq(\"id\", id);\n            });\n            await Promise.all(updates);\n            // Update local state\n            setLists((prev)=>prev.map((list)=>{\n                    const newOrderItem = newOrder.find((item)=>item.id === list.id);\n                    return newOrderItem ? {\n                        ...list,\n                        order_index: newOrderItem.order_index\n                    } : list;\n                }).sort((a, b)=>a.order_index - b.order_index));\n            return {\n                error: null\n            };\n        } catch (err) {\n            const errorMsg = err.message || \"Failed to reorder lists\";\n            setError(errorMsg);\n            return {\n                error: errorMsg\n            };\n        }\n    };\n    return {\n        lists,\n        loading,\n        error,\n        createList,\n        updateList,\n        deleteList,\n        reorderLists,\n        refetch: fetchLists\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9ob29rcy91c2VMaXN0cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OzhEQUU0QztBQUNTO0FBRzlDLFNBQVNHLFNBQVNDLE9BQXNCO0lBQzdDLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHTiwrQ0FBUUEsQ0FBUyxFQUFFO0lBQzdDLE1BQU0sQ0FBQ08sU0FBU0MsV0FBVyxHQUFHUiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNTLE9BQU9DLFNBQVMsR0FBR1YsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU1XLFdBQVdULGtFQUFZQTtJQUU3QixNQUFNVSxhQUFhO1FBQ2pCLElBQUksQ0FBQ1IsU0FBUztZQUNaRSxTQUFTLEVBQUU7WUFDWEUsV0FBVztZQUNYO1FBQ0Y7UUFFQSxJQUFJO1lBQ0ZBLFdBQVc7WUFDWCxNQUFNLEVBQUVLLElBQUksRUFBRUosT0FBT0ssVUFBVSxFQUFFLEdBQUcsTUFBTUgsU0FDdkNJLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsS0FDUEMsRUFBRSxDQUFDLFlBQVliLFNBQ2ZjLEtBQUssQ0FBQyxlQUFlO2dCQUFFQyxXQUFXO1lBQUs7WUFFMUMsSUFBSUwsWUFBWSxNQUFNQTtZQUN0QlIsU0FBU08sUUFBUSxFQUFFO1lBQ25CSCxTQUFTO1FBQ1gsRUFBRSxPQUFPVSxLQUFVO1lBQ2pCVixTQUFTVSxJQUFJQyxPQUFPLElBQUk7WUFDeEJDLFFBQVFiLEtBQUssQ0FBQyx5QkFBeUJXO1FBQ3pDLFNBQVU7WUFDUlosV0FBVztRQUNiO0lBQ0Y7SUFFQVAsZ0RBQVNBLENBQUM7UUFDUlc7UUFFQSxJQUFJLENBQUNSLFNBQVM7UUFFZCx3REFBd0Q7UUFDeEQsTUFBTW1CLFVBQVVaLFNBQ2JZLE9BQU8sQ0FBQyxpQkFBeUIsT0FBUm5CLFVBQ3pCb0IsRUFBRSxDQUNELG9CQUNBO1lBQ0VDLE9BQU87WUFDUEMsUUFBUTtZQUNSQyxPQUFPO1lBQ1BDLFFBQVEsZUFBdUIsT0FBUnhCO1FBQ3pCLEdBQ0EsQ0FBQ3lCO1lBQ0MsSUFBSUEsUUFBUUMsU0FBUyxLQUFLLFVBQVU7Z0JBQ2xDeEIsU0FBUyxDQUFDeUI7b0JBQ1IsTUFBTUMsU0FBU0QsS0FBS0UsSUFBSSxDQUFDLENBQUNDLElBQU1BLEVBQUVDLEVBQUUsS0FBS04sUUFBUU8sR0FBRyxDQUFDRCxFQUFFO29CQUN2RCxJQUFJSCxRQUFRLE9BQU9EO29CQUNuQixPQUFPOzJCQUFJQTt3QkFBTUYsUUFBUU8sR0FBRztxQkFBUyxDQUFDQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRUUsV0FBVyxHQUFHRCxFQUFFQyxXQUFXO2dCQUNwRjtZQUNGLE9BQU8sSUFBSVgsUUFBUUMsU0FBUyxLQUFLLFVBQVU7Z0JBQ3pDeEIsU0FBUyxDQUFDeUIsT0FDUkEsS0FDR1UsR0FBRyxDQUFDLENBQUNDLE9BQ0pBLEtBQUtQLEVBQUUsS0FBS04sUUFBUU8sR0FBRyxDQUFDRCxFQUFFLEdBQUlOLFFBQVFPLEdBQUcsR0FBWU0sTUFFdERMLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFRSxXQUFXLEdBQUdELEVBQUVDLFdBQVc7WUFFbkQsT0FBTyxJQUFJWCxRQUFRQyxTQUFTLEtBQUssVUFBVTtnQkFDekN4QixTQUFTLENBQUN5QixPQUFTQSxLQUFLSCxNQUFNLENBQUMsQ0FBQ2MsT0FBU0EsS0FBS1AsRUFBRSxLQUFLTixRQUFRYyxHQUFHLENBQUNSLEVBQUU7WUFDckU7UUFDRixHQUVEUyxTQUFTO1FBRVosT0FBTztZQUNMakMsU0FBU2tDLGFBQWEsQ0FBQ3RCO1FBQ3pCO0lBQ0EsdURBQXVEO0lBQ3pELEdBQUc7UUFBQ25CO0tBQVE7SUFFWixNQUFNMEMsYUFBYSxPQUFPQztRQUN4QixJQUFJLENBQUMzQyxTQUFTLE9BQU87WUFBRVMsTUFBTTtZQUFNSixPQUFPO1FBQW9CO1FBRTlELElBQUk7WUFDRix5Q0FBeUM7WUFDekMsTUFBTSxFQUFFSSxNQUFNbUMsYUFBYSxFQUFFLEdBQUcsTUFBTXJDLFNBQ25DSSxJQUFJLENBQUMsU0FDTEMsTUFBTSxDQUFDLGVBQ1BDLEVBQUUsQ0FBQyxZQUFZYixTQUNmYyxLQUFLLENBQUMsZUFBZTtnQkFBRUMsV0FBVztZQUFNLEdBQ3hDOEIsS0FBSyxDQUFDO1lBRVQsTUFBTUMsV0FBV0YsaUJBQWlCQSxjQUFjRyxNQUFNLEdBQUcsSUFDckRILGFBQWEsQ0FBQyxFQUFFLENBQUNSLFdBQVcsR0FBRyxJQUMvQjtZQUVKLE1BQU0sRUFBRTNCLElBQUksRUFBRUosT0FBTzJDLFdBQVcsRUFBRSxHQUFHLE1BQU16QyxTQUN4Q0ksSUFBSSxDQUFDLFNBQ0xzQyxNQUFNLENBQUM7Z0JBQUM7b0JBQ1BOO29CQUNBTyxVQUFVbEQ7b0JBQ1ZvQyxhQUFhVTtnQkFDZjthQUFFLEVBQ0RsQyxNQUFNLEdBQ051QyxNQUFNO1lBRVQsSUFBSUgsYUFBYSxNQUFNQTtZQUV2QjlDLFNBQVMsQ0FBQ3lCLE9BQVM7dUJBQUlBO29CQUFNbEI7aUJBQUssQ0FBQ3dCLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFRSxXQUFXLEdBQUdELEVBQUVDLFdBQVc7WUFDL0UsT0FBTztnQkFBRTNCO2dCQUFNSixPQUFPO1lBQUs7UUFDN0IsRUFBRSxPQUFPVyxLQUFVO1lBQ2pCLE1BQU1vQyxXQUFXcEMsSUFBSUMsT0FBTyxJQUFJO1lBQ2hDWCxTQUFTOEM7WUFDVCxPQUFPO2dCQUFFM0MsTUFBTTtnQkFBTUosT0FBTytDO1lBQVM7UUFDdkM7SUFDRjtJQUVBLE1BQU1DLGFBQWEsT0FBT3RCLElBQVl1QjtRQUNwQyxJQUFJO1lBQ0YsTUFBTSxFQUFFakQsT0FBT2tELFdBQVcsRUFBRSxHQUFHLE1BQU1oRCxTQUNsQ0ksSUFBSSxDQUFDLFNBQ0w2QyxNQUFNLENBQUNGLFNBQ1B6QyxFQUFFLENBQUMsTUFBTWtCO1lBRVosSUFBSXdCLGFBQWEsTUFBTUE7WUFFdkJyRCxTQUFTLENBQUN5QixPQUFTQSxLQUFLVSxHQUFHLENBQUNDLENBQUFBLE9BQzFCQSxLQUFLUCxFQUFFLEtBQUtBLEtBQUs7d0JBQUUsR0FBR08sSUFBSTt3QkFBRSxHQUFHZ0IsT0FBTztvQkFBQyxJQUFJaEI7WUFFN0MsT0FBTztnQkFBRWpDLE9BQU87WUFBSztRQUN2QixFQUFFLE9BQU9XLEtBQVU7WUFDakIsTUFBTW9DLFdBQVdwQyxJQUFJQyxPQUFPLElBQUk7WUFDaENYLFNBQVM4QztZQUNULE9BQU87Z0JBQUUvQyxPQUFPK0M7WUFBUztRQUMzQjtJQUNGO0lBRUEsTUFBTUssYUFBYSxPQUFPMUI7UUFDeEIsSUFBSTtZQUNGLE1BQU0sRUFBRTFCLE9BQU9xRCxXQUFXLEVBQUUsR0FBRyxNQUFNbkQsU0FDbENJLElBQUksQ0FBQyxTQUNMZ0QsTUFBTSxHQUNOOUMsRUFBRSxDQUFDLE1BQU1rQjtZQUVaLElBQUkyQixhQUFhLE1BQU1BO1lBRXZCeEQsU0FBUyxDQUFDeUIsT0FBU0EsS0FBS0gsTUFBTSxDQUFDYyxDQUFBQSxPQUFRQSxLQUFLUCxFQUFFLEtBQUtBO1lBQ25ELE9BQU87Z0JBQUUxQixPQUFPO1lBQUs7UUFDdkIsRUFBRSxPQUFPVyxLQUFVO1lBQ2pCLE1BQU1vQyxXQUFXcEMsSUFBSUMsT0FBTyxJQUFJO1lBQ2hDWCxTQUFTOEM7WUFDVCxPQUFPO2dCQUFFL0MsT0FBTytDO1lBQVM7UUFDM0I7SUFDRjtJQUVBLE1BQU1RLGVBQWUsT0FBT0M7UUFDMUIsSUFBSTtZQUNGLGdEQUFnRDtZQUNoRCxNQUFNUCxVQUFVTyxTQUFTeEIsR0FBRyxDQUFDO29CQUFDLEVBQUVOLEVBQUUsRUFBRUssV0FBVyxFQUFFO3VCQUMvQzdCLFNBQ0dJLElBQUksQ0FBQyxTQUNMNkMsTUFBTSxDQUFDO29CQUFFcEI7Z0JBQVksR0FDckJ2QixFQUFFLENBQUMsTUFBTWtCOztZQUdkLE1BQU0rQixRQUFRQyxHQUFHLENBQUNUO1lBRWxCLHFCQUFxQjtZQUNyQnBELFNBQVMsQ0FBQ3lCLE9BQVNBLEtBQUtVLEdBQUcsQ0FBQ0MsQ0FBQUE7b0JBQzFCLE1BQU0wQixlQUFlSCxTQUFTaEMsSUFBSSxDQUFDb0MsQ0FBQUEsT0FBUUEsS0FBS2xDLEVBQUUsS0FBS08sS0FBS1AsRUFBRTtvQkFDOUQsT0FBT2lDLGVBQWU7d0JBQUUsR0FBRzFCLElBQUk7d0JBQUVGLGFBQWE0QixhQUFhNUIsV0FBVztvQkFBQyxJQUFJRTtnQkFDN0UsR0FBR0wsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVFLFdBQVcsR0FBR0QsRUFBRUMsV0FBVztZQUUvQyxPQUFPO2dCQUFFL0IsT0FBTztZQUFLO1FBQ3ZCLEVBQUUsT0FBT1csS0FBVTtZQUNqQixNQUFNb0MsV0FBV3BDLElBQUlDLE9BQU8sSUFBSTtZQUNoQ1gsU0FBUzhDO1lBQ1QsT0FBTztnQkFBRS9DLE9BQU8rQztZQUFTO1FBQzNCO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xuRDtRQUNBRTtRQUNBRTtRQUNBcUM7UUFDQVc7UUFDQUk7UUFDQUc7UUFDQU0sU0FBUzFEO0lBQ1g7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvaG9va3MvdXNlTGlzdHMudHM/YzQ4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAL2xpYi9zdXBhYmFzZS9jbGllbnQnO1xuaW1wb3J0IHsgTGlzdCB9IGZyb20gJ0AvdHlwZXMvZGF0YWJhc2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdHMoYm9hcmRJZDogc3RyaW5nIHwgbnVsbCkge1xuICBjb25zdCBbbGlzdHMsIHNldExpc3RzXSA9IHVzZVN0YXRlPExpc3RbXT4oW10pO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoKTtcblxuICBjb25zdCBmZXRjaExpc3RzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghYm9hcmRJZCkge1xuICAgICAgc2V0TGlzdHMoW10pO1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbGlzdHMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdib2FyZF9pZCcsIGJvYXJkSWQpXG4gICAgICAgIC5vcmRlcignb3JkZXJfaW5kZXgnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KTtcblxuICAgICAgaWYgKGZldGNoRXJyb3IpIHRocm93IGZldGNoRXJyb3I7XG4gICAgICBzZXRMaXN0cyhkYXRhIHx8IFtdKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGZldGNoIGxpc3RzJyk7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBsaXN0czonLCBlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmZXRjaExpc3RzKCk7XG5cbiAgICBpZiAoIWJvYXJkSWQpIHJldHVybjtcblxuICAgIC8vIFN1YnNjcmliZSB0byByZWFsdGltZSBjaGFuZ2VzIGZvciBsaXN0cyBpbiB0aGlzIGJvYXJkXG4gICAgY29uc3QgY2hhbm5lbCA9IHN1cGFiYXNlXG4gICAgICAuY2hhbm5lbChgbGlzdHMtY2hhbmdlcy0ke2JvYXJkSWR9YClcbiAgICAgIC5vbihcbiAgICAgICAgJ3Bvc3RncmVzX2NoYW5nZXMnLFxuICAgICAgICB7XG4gICAgICAgICAgZXZlbnQ6ICcqJyxcbiAgICAgICAgICBzY2hlbWE6ICdwdWJsaWMnLFxuICAgICAgICAgIHRhYmxlOiAnbGlzdHMnLFxuICAgICAgICAgIGZpbHRlcjogYGJvYXJkX2lkPWVxLiR7Ym9hcmRJZH1gLFxuICAgICAgICB9LFxuICAgICAgICAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgIGlmIChwYXlsb2FkLmV2ZW50VHlwZSA9PT0gJ0lOU0VSVCcpIHtcbiAgICAgICAgICAgIHNldExpc3RzKChwcmV2KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IHByZXYuZmluZCgobCkgPT4gbC5pZCA9PT0gcGF5bG9hZC5uZXcuaWQpO1xuICAgICAgICAgICAgICBpZiAoZXhpc3RzKSByZXR1cm4gcHJldjtcbiAgICAgICAgICAgICAgcmV0dXJuIFsuLi5wcmV2LCBwYXlsb2FkLm5ldyBhcyBMaXN0XS5zb3J0KChhLCBiKSA9PiBhLm9yZGVyX2luZGV4IC0gYi5vcmRlcl9pbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWQuZXZlbnRUeXBlID09PSAnVVBEQVRFJykge1xuICAgICAgICAgICAgc2V0TGlzdHMoKHByZXYpID0+XG4gICAgICAgICAgICAgIHByZXZcbiAgICAgICAgICAgICAgICAubWFwKChsaXN0KSA9PlxuICAgICAgICAgICAgICAgICAgbGlzdC5pZCA9PT0gcGF5bG9hZC5uZXcuaWQgPyAocGF5bG9hZC5uZXcgYXMgTGlzdCkgOiBsaXN0XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLm9yZGVyX2luZGV4IC0gYi5vcmRlcl9pbmRleClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkLmV2ZW50VHlwZSA9PT0gJ0RFTEVURScpIHtcbiAgICAgICAgICAgIHNldExpc3RzKChwcmV2KSA9PiBwcmV2LmZpbHRlcigobGlzdCkgPT4gbGlzdC5pZCAhPT0gcGF5bG9hZC5vbGQuaWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdXBhYmFzZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbYm9hcmRJZF0pO1xuXG4gIGNvbnN0IGNyZWF0ZUxpc3QgPSBhc3luYyAodGl0bGU6IHN0cmluZykgPT4ge1xuICAgIGlmICghYm9hcmRJZCkgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6ICdObyBib2FyZCBzZWxlY3RlZCcgfTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgdGhlIG1heCBvcmRlcl9pbmRleCBmb3IgdGhpcyBib2FyZFxuICAgICAgY29uc3QgeyBkYXRhOiBleGlzdGluZ0xpc3RzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbGlzdHMnKVxuICAgICAgICAuc2VsZWN0KCdvcmRlcl9pbmRleCcpXG4gICAgICAgIC5lcSgnYm9hcmRfaWQnLCBib2FyZElkKVxuICAgICAgICAub3JkZXIoJ29yZGVyX2luZGV4JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAgIC5saW1pdCgxKTtcblxuICAgICAgY29uc3QgbWF4T3JkZXIgPSBleGlzdGluZ0xpc3RzICYmIGV4aXN0aW5nTGlzdHMubGVuZ3RoID4gMCBcbiAgICAgICAgPyBleGlzdGluZ0xpc3RzWzBdLm9yZGVyX2luZGV4ICsgMSBcbiAgICAgICAgOiAwO1xuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBjcmVhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xpc3RzJylcbiAgICAgICAgLmluc2VydChbeyBcbiAgICAgICAgICB0aXRsZSwgXG4gICAgICAgICAgYm9hcmRfaWQ6IGJvYXJkSWQsXG4gICAgICAgICAgb3JkZXJfaW5kZXg6IG1heE9yZGVyIFxuICAgICAgICB9XSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGNyZWF0ZUVycm9yKSB0aHJvdyBjcmVhdGVFcnJvcjtcbiAgICAgIFxuICAgICAgc2V0TGlzdHMoKHByZXYpID0+IFsuLi5wcmV2LCBkYXRhXS5zb3J0KChhLCBiKSA9PiBhLm9yZGVyX2luZGV4IC0gYi5vcmRlcl9pbmRleCkpO1xuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc3QgZXJyb3JNc2cgPSBlcnIubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGNyZWF0ZSBsaXN0JztcbiAgICAgIHNldEVycm9yKGVycm9yTXNnKTtcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBlcnJvck1zZyB9O1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB1cGRhdGVMaXN0ID0gYXN5bmMgKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8TGlzdD4pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdsaXN0cycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlcylcbiAgICAgICAgLmVxKCdpZCcsIGlkKTtcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB0aHJvdyB1cGRhdGVFcnJvcjtcblxuICAgICAgc2V0TGlzdHMoKHByZXYpID0+IHByZXYubWFwKGxpc3QgPT4gXG4gICAgICAgIGxpc3QuaWQgPT09IGlkID8geyAuLi5saXN0LCAuLi51cGRhdGVzIH0gOiBsaXN0XG4gICAgICApKTtcbiAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH07XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgbGlzdCc7XG4gICAgICBzZXRFcnJvcihlcnJvck1zZyk7XG4gICAgICByZXR1cm4geyBlcnJvcjogZXJyb3JNc2cgfTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZGVsZXRlTGlzdCA9IGFzeW5jIChpZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3I6IGRlbGV0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbGlzdHMnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIGlkKTtcblxuICAgICAgaWYgKGRlbGV0ZUVycm9yKSB0aHJvdyBkZWxldGVFcnJvcjtcblxuICAgICAgc2V0TGlzdHMoKHByZXYpID0+IHByZXYuZmlsdGVyKGxpc3QgPT4gbGlzdC5pZCAhPT0gaWQpKTtcbiAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH07XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBkZWxldGUgbGlzdCc7XG4gICAgICBzZXRFcnJvcihlcnJvck1zZyk7XG4gICAgICByZXR1cm4geyBlcnJvcjogZXJyb3JNc2cgfTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVvcmRlckxpc3RzID0gYXN5bmMgKG5ld09yZGVyOiB7IGlkOiBzdHJpbmc7IG9yZGVyX2luZGV4OiBudW1iZXIgfVtdKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVwZGF0ZSBhbGwgbGlzdHMgaW4gYSB0cmFuc2FjdGlvbi1saWtlIG1hbm5lclxuICAgICAgY29uc3QgdXBkYXRlcyA9IG5ld09yZGVyLm1hcCgoeyBpZCwgb3JkZXJfaW5kZXggfSkgPT5cbiAgICAgICAgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnbGlzdHMnKVxuICAgICAgICAgIC51cGRhdGUoeyBvcmRlcl9pbmRleCB9KVxuICAgICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHVwZGF0ZXMpO1xuXG4gICAgICAvLyBVcGRhdGUgbG9jYWwgc3RhdGVcbiAgICAgIHNldExpc3RzKChwcmV2KSA9PiBwcmV2Lm1hcChsaXN0ID0+IHtcbiAgICAgICAgY29uc3QgbmV3T3JkZXJJdGVtID0gbmV3T3JkZXIuZmluZChpdGVtID0+IGl0ZW0uaWQgPT09IGxpc3QuaWQpO1xuICAgICAgICByZXR1cm4gbmV3T3JkZXJJdGVtID8geyAuLi5saXN0LCBvcmRlcl9pbmRleDogbmV3T3JkZXJJdGVtLm9yZGVyX2luZGV4IH0gOiBsaXN0O1xuICAgICAgfSkuc29ydCgoYSwgYikgPT4gYS5vcmRlcl9pbmRleCAtIGIub3JkZXJfaW5kZXgpKTtcblxuICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc3QgZXJyb3JNc2cgPSBlcnIubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHJlb3JkZXIgbGlzdHMnO1xuICAgICAgc2V0RXJyb3IoZXJyb3JNc2cpO1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IGVycm9yTXNnIH07XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbGlzdHMsXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBjcmVhdGVMaXN0LFxuICAgIHVwZGF0ZUxpc3QsXG4gICAgZGVsZXRlTGlzdCxcbiAgICByZW9yZGVyTGlzdHMsXG4gICAgcmVmZXRjaDogZmV0Y2hMaXN0cyxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImNyZWF0ZUNsaWVudCIsInVzZUxpc3RzIiwiYm9hcmRJZCIsImxpc3RzIiwic2V0TGlzdHMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJzdXBhYmFzZSIsImZldGNoTGlzdHMiLCJkYXRhIiwiZmV0Y2hFcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiZXJyIiwibWVzc2FnZSIsImNvbnNvbGUiLCJjaGFubmVsIiwib24iLCJldmVudCIsInNjaGVtYSIsInRhYmxlIiwiZmlsdGVyIiwicGF5bG9hZCIsImV2ZW50VHlwZSIsInByZXYiLCJleGlzdHMiLCJmaW5kIiwibCIsImlkIiwibmV3Iiwic29ydCIsImEiLCJiIiwib3JkZXJfaW5kZXgiLCJtYXAiLCJsaXN0Iiwib2xkIiwic3Vic2NyaWJlIiwicmVtb3ZlQ2hhbm5lbCIsImNyZWF0ZUxpc3QiLCJ0aXRsZSIsImV4aXN0aW5nTGlzdHMiLCJsaW1pdCIsIm1heE9yZGVyIiwibGVuZ3RoIiwiY3JlYXRlRXJyb3IiLCJpbnNlcnQiLCJib2FyZF9pZCIsInNpbmdsZSIsImVycm9yTXNnIiwidXBkYXRlTGlzdCIsInVwZGF0ZXMiLCJ1cGRhdGVFcnJvciIsInVwZGF0ZSIsImRlbGV0ZUxpc3QiLCJkZWxldGVFcnJvciIsImRlbGV0ZSIsInJlb3JkZXJMaXN0cyIsIm5ld09yZGVyIiwiUHJvbWlzZSIsImFsbCIsIm5ld09yZGVySXRlbSIsIml0ZW0iLCJyZWZldGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/hooks/useLists.ts\n"));

/***/ })

});