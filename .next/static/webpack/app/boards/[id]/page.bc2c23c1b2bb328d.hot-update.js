"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/boards/[id]/page",{

/***/ "(app-pages-browser)/./lib/hooks/useCards.ts":
/*!*******************************!*\
  !*** ./lib/hooks/useCards.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCards: function() { return /* binding */ useCards; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase/client */ \"(app-pages-browser)/./lib/supabase/client.ts\");\n/* harmony import */ var _lib_utils_notifications__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/utils/notifications */ \"(app-pages-browser)/./lib/utils/notifications.ts\");\n/* __next_internal_client_entry_do_not_use__ useCards auto */ \n\n\nfunction useCards(listId) {\n    const [cards, setCards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const supabase = (0,_lib_supabase_client__WEBPACK_IMPORTED_MODULE_1__.createClient)();\n    const fetchCards = async ()=>{\n        if (!listId) {\n            setCards([]);\n            setLoading(false);\n            return;\n        }\n        try {\n            setLoading(true);\n            const { data, error: fetchError } = await supabase.from(\"cards\").select(\"*\").eq(\"list_id\", listId).order(\"order_index\", {\n                ascending: true\n            });\n            if (fetchError) throw fetchError;\n            setCards(data || []);\n            setError(null);\n        } catch (err) {\n            setError(err.message || \"Failed to fetch cards\");\n            console.error(\"Error fetching cards:\", err);\n        } finally{\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchCards();\n        if (!listId) return;\n        // Subscribe to realtime changes for cards in this list\n        const channel = supabase.channel(\"cards-changes-\".concat(listId)).on(\"postgres_changes\", {\n            event: \"*\",\n            schema: \"public\",\n            table: \"cards\",\n            filter: \"list_id=eq.\".concat(listId)\n        }, (payload)=>{\n            if (payload.eventType === \"INSERT\") {\n                setCards((prev)=>{\n                    const exists = prev.find((c)=>c.id === payload.new.id);\n                    if (exists) return prev;\n                    return [\n                        ...prev,\n                        payload.new\n                    ].sort((a, b)=>a.order_index - b.order_index);\n                });\n            } else if (payload.eventType === \"UPDATE\") {\n                setCards((prev)=>prev.map((card)=>card.id === payload.new.id ? payload.new : card).sort((a, b)=>a.order_index - b.order_index));\n            } else if (payload.eventType === \"DELETE\") {\n                setCards((prev)=>prev.filter((card)=>card.id !== payload.old.id));\n            }\n        }).subscribe();\n        return ()=>{\n            supabase.removeChannel(channel);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        listId\n    ]);\n    const createCard = async (title, description, startDate, dueDate)=>{\n        if (!listId) return {\n            data: null,\n            error: \"No list selected\"\n        };\n        try {\n            // Get the max order_index for this list\n            const { data: existingCards } = await supabase.from(\"cards\").select(\"order_index\").eq(\"list_id\", listId).order(\"order_index\", {\n                ascending: false\n            }).limit(1);\n            const maxOrder = existingCards && existingCards.length > 0 ? existingCards[0].order_index + 1 : 0;\n            const { data, error: createError } = await supabase.from(\"cards\").insert([\n                {\n                    title,\n                    description: description || null,\n                    start_date: startDate || null,\n                    due_date: dueDate || null,\n                    completed: false,\n                    list_id: listId,\n                    order_index: maxOrder\n                }\n            ]).select().single();\n            if (createError) throw createError;\n            setCards((prev)=>[\n                    ...prev,\n                    data\n                ].sort((a, b)=>a.order_index - b.order_index));\n            return {\n                data,\n                error: null\n            };\n        } catch (err) {\n            const errorMsg = err.message || \"Failed to create card\";\n            setError(errorMsg);\n            return {\n                data: null,\n                error: errorMsg\n            };\n        }\n    };\n    const updateCard = async (id, updates)=>{\n        try {\n            const { error: updateError } = await supabase.from(\"cards\").update(updates).eq(\"id\", id);\n            if (updateError) throw updateError;\n            setCards((prev)=>prev.map((card)=>card.id === id ? {\n                        ...card,\n                        ...updates\n                    } : card));\n            return {\n                error: null\n            };\n        } catch (err) {\n            const errorMsg = err.message || \"Failed to update card\";\n            setError(errorMsg);\n            return {\n                error: errorMsg\n            };\n        }\n    };\n    const deleteCard = async (id)=>{\n        try {\n            const { error: deleteError } = await supabase.from(\"cards\").delete().eq(\"id\", id);\n            if (deleteError) throw deleteError;\n            setCards((prev)=>prev.filter((card)=>card.id !== id));\n            (0,_lib_utils_notifications__WEBPACK_IMPORTED_MODULE_2__.showNotification)(\"T\\xe2che supprim\\xe9e avec succ\\xe8s\", \"success\");\n            return {\n                error: null\n            };\n        } catch (err) {\n            const errorMsg = err.message || \"Failed to delete card\";\n            setError(errorMsg);\n            (0,_lib_utils_notifications__WEBPACK_IMPORTED_MODULE_2__.showNotification)(errorMsg, \"error\");\n            console.error(\"Error deleting card:\", err);\n            return {\n                error: errorMsg\n            };\n        }\n    };\n    const reorderCards = async (newOrder)=>{\n        try {\n            const updates = newOrder.map((param)=>{\n                let { id, order_index } = param;\n                return supabase.from(\"cards\").update({\n                    order_index\n                }).eq(\"id\", id);\n            });\n            await Promise.all(updates);\n            setCards((prev)=>prev.map((card)=>{\n                    const newOrderItem = newOrder.find((item)=>item.id === card.id);\n                    return newOrderItem ? {\n                        ...card,\n                        order_index: newOrderItem.order_index\n                    } : card;\n                }).sort((a, b)=>a.order_index - b.order_index));\n            return {\n                error: null\n            };\n        } catch (err) {\n            const errorMsg = err.message || \"Failed to reorder cards\";\n            setError(errorMsg);\n            return {\n                error: errorMsg\n            };\n        }\n    };\n    const moveCard = async (cardId, newListId, newOrderIndex)=>{\n        try {\n            const { error: moveError } = await supabase.from(\"cards\").update({\n                list_id: newListId,\n                order_index: newOrderIndex\n            }).eq(\"id\", cardId);\n            if (moveError) throw moveError;\n            // Remove from current list (the card will appear in the new list via realtime)\n            setCards((prev)=>prev.filter((card)=>card.id !== cardId));\n            return {\n                error: null\n            };\n        } catch (err) {\n            const errorMsg = err.message || \"Failed to move card\";\n            setError(errorMsg);\n            return {\n                error: errorMsg\n            };\n        }\n    };\n    const getCardAssignments = async (cardId)=>{\n        try {\n            const { data, error } = await supabase.from(\"card_assignments\").select(\"*\").eq(\"card_id\", cardId);\n            if (error) throw error;\n            return data || [];\n        } catch (err) {\n            console.error(\"Error fetching card assignments:\", err);\n            return [];\n        }\n    };\n    const assignUserToCard = async (cardId, userId)=>{\n        try {\n            const { data, error } = await supabase.from(\"card_assignments\").insert([\n                {\n                    card_id: cardId,\n                    user_id: userId\n                }\n            ]).select().single();\n            if (error) throw error;\n            return {\n                data,\n                error: null\n            };\n        } catch (err) {\n            const errorMsg = err.message || \"Failed to assign user\";\n            return {\n                data: null,\n                error: errorMsg\n            };\n        }\n    };\n    const unassignUserFromCard = async (cardId, userId)=>{\n        try {\n            const { error } = await supabase.from(\"card_assignments\").delete().eq(\"card_id\", cardId).eq(\"user_id\", userId);\n            if (error) throw error;\n            return {\n                error: null\n            };\n        } catch (err) {\n            const errorMsg = err.message || \"Failed to unassign user\";\n            return {\n                error: errorMsg\n            };\n        }\n    };\n    return {\n        cards,\n        loading,\n        error,\n        createCard,\n        updateCard,\n        deleteCard,\n        reorderCards,\n        moveCard,\n        getCardAssignments,\n        assignUserToCard,\n        unassignUserFromCard,\n        refetch: fetchCards\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9ob29rcy91c2VDYXJkcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs4REFFNEM7QUFDUztBQUVRO0FBRXRELFNBQVNJLFNBQVNDLE1BQXFCO0lBQzVDLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHUCwrQ0FBUUEsQ0FBUyxFQUFFO0lBQzdDLE1BQU0sQ0FBQ1EsU0FBU0MsV0FBVyxHQUFHVCwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNVLE9BQU9DLFNBQVMsR0FBR1gsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU1ZLFdBQVdWLGtFQUFZQTtJQUU3QixNQUFNVyxhQUFhO1FBQ2pCLElBQUksQ0FBQ1IsUUFBUTtZQUNYRSxTQUFTLEVBQUU7WUFDWEUsV0FBVztZQUNYO1FBQ0Y7UUFFQSxJQUFJO1lBQ0ZBLFdBQVc7WUFDWCxNQUFNLEVBQUVLLElBQUksRUFBRUosT0FBT0ssVUFBVSxFQUFFLEdBQUcsTUFBTUgsU0FDdkNJLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUMsS0FDUEMsRUFBRSxDQUFDLFdBQVdiLFFBQ2RjLEtBQUssQ0FBQyxlQUFlO2dCQUFFQyxXQUFXO1lBQUs7WUFFMUMsSUFBSUwsWUFBWSxNQUFNQTtZQUN0QlIsU0FBU08sUUFBUSxFQUFFO1lBQ25CSCxTQUFTO1FBQ1gsRUFBRSxPQUFPVSxLQUFVO1lBQ2pCVixTQUFTVSxJQUFJQyxPQUFPLElBQUk7WUFDeEJDLFFBQVFiLEtBQUssQ0FBQyx5QkFBeUJXO1FBQ3pDLFNBQVU7WUFDUlosV0FBVztRQUNiO0lBQ0Y7SUFFQVIsZ0RBQVNBLENBQUM7UUFDUlk7UUFFQSxJQUFJLENBQUNSLFFBQVE7UUFFYix1REFBdUQ7UUFDdkQsTUFBTW1CLFVBQVVaLFNBQ2JZLE9BQU8sQ0FBQyxpQkFBd0IsT0FBUG5CLFNBQ3pCb0IsRUFBRSxDQUNELG9CQUNBO1lBQ0VDLE9BQU87WUFDUEMsUUFBUTtZQUNSQyxPQUFPO1lBQ1BDLFFBQVEsY0FBcUIsT0FBUHhCO1FB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QUVaLE9BQU9xRDtZQUFTO1FBQzNCO0lBQ0Y7SUFFQSxPQUFPO1FBQ0x6RDtRQUNBRTtRQUNBRTtRQUNBcUM7UUFDQWlCO1FBQ0FJO1FBQ0FHO1FBQ0FNO1FBQ0FLO1FBQ0FDO1FBQ0FJO1FBQ0FDLFNBQVMzRTtJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2hvb2tzL3VzZUNhcmRzLnRzP2E2MTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQC9saWIvc3VwYWJhc2UvY2xpZW50JztcbmltcG9ydCB7IENhcmQsIENhcmRBc3NpZ25tZW50IH0gZnJvbSAnQC90eXBlcy9kYXRhYmFzZSc7XG5pbXBvcnQgeyBzaG93Tm90aWZpY2F0aW9uIH0gZnJvbSAnQC9saWIvdXRpbHMvbm90aWZpY2F0aW9ucyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYXJkcyhsaXN0SWQ6IHN0cmluZyB8IG51bGwpIHtcbiAgY29uc3QgW2NhcmRzLCBzZXRDYXJkc10gPSB1c2VTdGF0ZTxDYXJkW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KCk7XG5cbiAgY29uc3QgZmV0Y2hDYXJkcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWxpc3RJZCkge1xuICAgICAgc2V0Q2FyZHMoW10pO1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY2FyZHMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdsaXN0X2lkJywgbGlzdElkKVxuICAgICAgICAub3JkZXIoJ29yZGVyX2luZGV4JywgeyBhc2NlbmRpbmc6IHRydWUgfSk7XG5cbiAgICAgIGlmIChmZXRjaEVycm9yKSB0aHJvdyBmZXRjaEVycm9yO1xuICAgICAgc2V0Q2FyZHMoZGF0YSB8fCBbXSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBmZXRjaCBjYXJkcycpO1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2FyZHM6JywgZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZmV0Y2hDYXJkcygpO1xuXG4gICAgaWYgKCFsaXN0SWQpIHJldHVybjtcblxuICAgIC8vIFN1YnNjcmliZSB0byByZWFsdGltZSBjaGFuZ2VzIGZvciBjYXJkcyBpbiB0aGlzIGxpc3RcbiAgICBjb25zdCBjaGFubmVsID0gc3VwYWJhc2VcbiAgICAgIC5jaGFubmVsKGBjYXJkcy1jaGFuZ2VzLSR7bGlzdElkfWApXG4gICAgICAub24oXG4gICAgICAgICdwb3N0Z3Jlc19jaGFuZ2VzJyxcbiAgICAgICAge1xuICAgICAgICAgIGV2ZW50OiAnKicsXG4gICAgICAgICAgc2NoZW1hOiAncHVibGljJyxcbiAgICAgICAgICB0YWJsZTogJ2NhcmRzJyxcbiAgICAgICAgICBmaWx0ZXI6IGBsaXN0X2lkPWVxLiR7bGlzdElkfWAsXG4gICAgICAgIH0sXG4gICAgICAgIChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgaWYgKHBheWxvYWQuZXZlbnRUeXBlID09PSAnSU5TRVJUJykge1xuICAgICAgICAgICAgc2V0Q2FyZHMoKHByZXYpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gcHJldi5maW5kKChjKSA9PiBjLmlkID09PSBwYXlsb2FkLm5ldy5pZCk7XG4gICAgICAgICAgICAgIGlmIChleGlzdHMpIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIHBheWxvYWQubmV3IGFzIENhcmRdLnNvcnQoKGEsIGIpID0+IGEub3JkZXJfaW5kZXggLSBiLm9yZGVyX2luZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZC5ldmVudFR5cGUgPT09ICdVUERBVEUnKSB7XG4gICAgICAgICAgICBzZXRDYXJkcygocHJldikgPT5cbiAgICAgICAgICAgICAgcHJldlxuICAgICAgICAgICAgICAgIC5tYXAoKGNhcmQpID0+XG4gICAgICAgICAgICAgICAgICBjYXJkLmlkID09PSBwYXlsb2FkLm5ldy5pZCA/IChwYXlsb2FkLm5ldyBhcyBDYXJkKSA6IGNhcmRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEub3JkZXJfaW5kZXggLSBiLm9yZGVyX2luZGV4KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWQuZXZlbnRUeXBlID09PSAnREVMRVRFJykge1xuICAgICAgICAgICAgc2V0Q2FyZHMoKHByZXYpID0+IHByZXYuZmlsdGVyKChjYXJkKSA9PiBjYXJkLmlkICE9PSBwYXlsb2FkLm9sZC5pZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1cGFiYXNlLnJlbW92ZUNoYW5uZWwoY2hhbm5lbCk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtsaXN0SWRdKTtcblxuICBjb25zdCBjcmVhdGVDYXJkID0gYXN5bmMgKHRpdGxlOiBzdHJpbmcsIGRlc2NyaXB0aW9uPzogc3RyaW5nLCBzdGFydERhdGU/OiBzdHJpbmcsIGR1ZURhdGU/OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWxpc3RJZCkgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6ICdObyBsaXN0IHNlbGVjdGVkJyB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCB0aGUgbWF4IG9yZGVyX2luZGV4IGZvciB0aGlzIGxpc3RcbiAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdDYXJkcyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NhcmRzJylcbiAgICAgICAgLnNlbGVjdCgnb3JkZXJfaW5kZXgnKVxuICAgICAgICAuZXEoJ2xpc3RfaWQnLCBsaXN0SWQpXG4gICAgICAgIC5vcmRlcignb3JkZXJfaW5kZXgnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgLmxpbWl0KDEpO1xuXG4gICAgICBjb25zdCBtYXhPcmRlciA9IGV4aXN0aW5nQ2FyZHMgJiYgZXhpc3RpbmdDYXJkcy5sZW5ndGggPiAwIFxuICAgICAgICA/IGV4aXN0aW5nQ2FyZHNbMF0ub3JkZXJfaW5kZXggKyAxIFxuICAgICAgICA6IDA7XG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IGNyZWF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY2FyZHMnKVxuICAgICAgICAuaW5zZXJ0KFt7IFxuICAgICAgICAgIHRpdGxlLCBcbiAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfHwgbnVsbCxcbiAgICAgICAgICBzdGFydF9kYXRlOiBzdGFydERhdGUgfHwgbnVsbCxcbiAgICAgICAgICBkdWVfZGF0ZTogZHVlRGF0ZSB8fCBudWxsLFxuICAgICAgICAgIGNvbXBsZXRlZDogZmFsc2UsXG4gICAgICAgICAgbGlzdF9pZDogbGlzdElkLFxuICAgICAgICAgIG9yZGVyX2luZGV4OiBtYXhPcmRlciBcbiAgICAgICAgfV0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGlmIChjcmVhdGVFcnJvcikgdGhyb3cgY3JlYXRlRXJyb3I7XG4gICAgICBcbiAgICAgIHNldENhcmRzKChwcmV2KSA9PiBbLi4ucHJldiwgZGF0YV0uc29ydCgoYSwgYikgPT4gYS5vcmRlcl9pbmRleCAtIGIub3JkZXJfaW5kZXgpKTtcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgY2FyZCc7XG4gICAgICBzZXRFcnJvcihlcnJvck1zZyk7XG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogZXJyb3JNc2cgfTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlQ2FyZCA9IGFzeW5jIChpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPENhcmQ+KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY2FyZHMnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZXMpXG4gICAgICAgIC5lcSgnaWQnLCBpZCk7XG5cbiAgICAgIGlmICh1cGRhdGVFcnJvcikgdGhyb3cgdXBkYXRlRXJyb3I7XG5cbiAgICAgIHNldENhcmRzKChwcmV2KSA9PiBwcmV2Lm1hcChjYXJkID0+IFxuICAgICAgICBjYXJkLmlkID09PSBpZCA/IHsgLi4uY2FyZCwgLi4udXBkYXRlcyB9IDogY2FyZFxuICAgICAgKSk7XG4gICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zdCBlcnJvck1zZyA9IGVyci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdXBkYXRlIGNhcmQnO1xuICAgICAgc2V0RXJyb3IoZXJyb3JNc2cpO1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IGVycm9yTXNnIH07XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGRlbGV0ZUNhcmQgPSBhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yOiBkZWxldGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NhcmRzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnaWQnLCBpZCk7XG5cbiAgICAgIGlmIChkZWxldGVFcnJvcikgdGhyb3cgZGVsZXRlRXJyb3I7XG5cbiAgICAgIHNldENhcmRzKChwcmV2KSA9PiBwcmV2LmZpbHRlcihjYXJkID0+IGNhcmQuaWQgIT09IGlkKSk7XG4gICAgICBzaG93Tm90aWZpY2F0aW9uKCdUw6JjaGUgc3VwcHJpbcOpZSBhdmVjIHN1Y2PDqHMnLCAnc3VjY2VzcycpO1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc3QgZXJyb3JNc2cgPSBlcnIubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGRlbGV0ZSBjYXJkJztcbiAgICAgIHNldEVycm9yKGVycm9yTXNnKTtcbiAgICAgIHNob3dOb3RpZmljYXRpb24oZXJyb3JNc2csICdlcnJvcicpO1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgY2FyZDonLCBlcnIpO1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IGVycm9yTXNnIH07XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlb3JkZXJDYXJkcyA9IGFzeW5jIChuZXdPcmRlcjogeyBpZDogc3RyaW5nOyBvcmRlcl9pbmRleDogbnVtYmVyIH1bXSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cGRhdGVzID0gbmV3T3JkZXIubWFwKCh7IGlkLCBvcmRlcl9pbmRleCB9KSA9PlxuICAgICAgICBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdjYXJkcycpXG4gICAgICAgICAgLnVwZGF0ZSh7IG9yZGVyX2luZGV4IH0pXG4gICAgICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodXBkYXRlcyk7XG5cbiAgICAgIHNldENhcmRzKChwcmV2KSA9PiBwcmV2Lm1hcChjYXJkID0+IHtcbiAgICAgICAgY29uc3QgbmV3T3JkZXJJdGVtID0gbmV3T3JkZXIuZmluZChpdGVtID0+IGl0ZW0uaWQgPT09IGNhcmQuaWQpO1xuICAgICAgICByZXR1cm4gbmV3T3JkZXJJdGVtID8geyAuLi5jYXJkLCBvcmRlcl9pbmRleDogbmV3T3JkZXJJdGVtLm9yZGVyX2luZGV4IH0gOiBjYXJkO1xuICAgICAgfSkuc29ydCgoYSwgYikgPT4gYS5vcmRlcl9pbmRleCAtIGIub3JkZXJfaW5kZXgpKTtcblxuICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY29uc3QgZXJyb3JNc2cgPSBlcnIubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHJlb3JkZXIgY2FyZHMnO1xuICAgICAgc2V0RXJyb3IoZXJyb3JNc2cpO1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IGVycm9yTXNnIH07XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG1vdmVDYXJkID0gYXN5bmMgKGNhcmRJZDogc3RyaW5nLCBuZXdMaXN0SWQ6IHN0cmluZywgbmV3T3JkZXJJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3I6IG1vdmVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NhcmRzJylcbiAgICAgICAgLnVwZGF0ZSh7IGxpc3RfaWQ6IG5ld0xpc3RJZCwgb3JkZXJfaW5kZXg6IG5ld09yZGVySW5kZXggfSlcbiAgICAgICAgLmVxKCdpZCcsIGNhcmRJZCk7XG5cbiAgICAgIGlmIChtb3ZlRXJyb3IpIHRocm93IG1vdmVFcnJvcjtcblxuICAgICAgLy8gUmVtb3ZlIGZyb20gY3VycmVudCBsaXN0ICh0aGUgY2FyZCB3aWxsIGFwcGVhciBpbiB0aGUgbmV3IGxpc3QgdmlhIHJlYWx0aW1lKVxuICAgICAgc2V0Q2FyZHMoKHByZXYpID0+IHByZXYuZmlsdGVyKGNhcmQgPT4gY2FyZC5pZCAhPT0gY2FyZElkKSk7XG4gICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zdCBlcnJvck1zZyA9IGVyci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gbW92ZSBjYXJkJztcbiAgICAgIHNldEVycm9yKGVycm9yTXNnKTtcbiAgICAgIHJldHVybiB7IGVycm9yOiBlcnJvck1zZyB9O1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRDYXJkQXNzaWdubWVudHMgPSBhc3luYyAoY2FyZElkOiBzdHJpbmcpOiBQcm9taXNlPENhcmRBc3NpZ25tZW50W10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NhcmRfYXNzaWdubWVudHMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdjYXJkX2lkJywgY2FyZElkKTtcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICAgIHJldHVybiBkYXRhIHx8IFtdO1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjYXJkIGFzc2lnbm1lbnRzOicsIGVycik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGFzc2lnblVzZXJUb0NhcmQgPSBhc3luYyAoY2FyZElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjYXJkX2Fzc2lnbm1lbnRzJylcbiAgICAgICAgLmluc2VydChbeyBjYXJkX2lkOiBjYXJkSWQsIHVzZXJfaWQ6IHVzZXJJZCB9XSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBhc3NpZ24gdXNlcic7XG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogZXJyb3JNc2cgfTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdW5hc3NpZ25Vc2VyRnJvbUNhcmQgPSBhc3luYyAoY2FyZElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjYXJkX2Fzc2lnbm1lbnRzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnY2FyZF9pZCcsIGNhcmRJZClcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKTtcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH07XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB1bmFzc2lnbiB1c2VyJztcbiAgICAgIHJldHVybiB7IGVycm9yOiBlcnJvck1zZyB9O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNhcmRzLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgY3JlYXRlQ2FyZCxcbiAgICB1cGRhdGVDYXJkLFxuICAgIGRlbGV0ZUNhcmQsXG4gICAgcmVvcmRlckNhcmRzLFxuICAgIG1vdmVDYXJkLFxuICAgIGdldENhcmRBc3NpZ25tZW50cyxcbiAgICBhc3NpZ25Vc2VyVG9DYXJkLFxuICAgIHVuYXNzaWduVXNlckZyb21DYXJkLFxuICAgIHJlZmV0Y2g6IGZldGNoQ2FyZHMsXG4gIH07XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJjcmVhdGVDbGllbnQiLCJzaG93Tm90aWZpY2F0aW9uIiwidXNlQ2FyZHMiLCJsaXN0SWQiLCJjYXJkcyIsInNldENhcmRzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwic3VwYWJhc2UiLCJmZXRjaENhcmRzIiwiZGF0YSIsImZldGNoRXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJvcmRlciIsImFzY2VuZGluZyIsImVyciIsIm1lc3NhZ2UiLCJjb25zb2xlIiwiY2hhbm5lbCIsIm9uIiwiZXZlbnQiLCJzY2hlbWEiLCJ0YWJsZSIsImZpbHRlciIsInBheWxvYWQiLCJldmVudFR5cGUiLCJwcmV2IiwiZXhpc3RzIiwiZmluZCIsImMiLCJpZCIsIm5ldyIsInNvcnQiLCJhIiwiYiIsIm9yZGVyX2luZGV4IiwibWFwIiwiY2FyZCIsIm9sZCIsInN1YnNjcmliZSIsInJlbW92ZUNoYW5uZWwiLCJjcmVhdGVDYXJkIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInN0YXJ0RGF0ZSIsImR1ZURhdGUiLCJleGlzdGluZ0NhcmRzIiwibGltaXQiLCJtYXhPcmRlciIsImxlbmd0aCIsImNyZWF0ZUVycm9yIiwiaW5zZXJ0Iiwic3RhcnRfZGF0ZSIsImR1ZV9kYXRlIiwiY29tcGxldGVkIiwibGlzdF9pZCIsInNpbmdsZSIsImVycm9yTXNnIiwidXBkYXRlQ2FyZCIsInVwZGF0ZXMiLCJ1cGRhdGVFcnJvciIsInVwZGF0ZSIsImRlbGV0ZUNhcmQiLCJkZWxldGVFcnJvciIsImRlbGV0ZSIsInJlb3JkZXJDYXJkcyIsIm5ld09yZGVyIiwiUHJvbWlzZSIsImFsbCIsIm5ld09yZGVySXRlbSIsIml0ZW0iLCJtb3ZlQ2FyZCIsImNhcmRJZCIsIm5ld0xpc3RJZCIsIm5ld09yZGVySW5kZXgiLCJtb3ZlRXJyb3IiLCJnZXRDYXJkQXNzaWdubWVudHMiLCJhc3NpZ25Vc2VyVG9DYXJkIiwidXNlcklkIiwiY2FyZF9pZCIsInVzZXJfaWQiLCJ1bmFzc2lnblVzZXJGcm9tQ2FyZCIsInJlZmV0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/hooks/useCards.ts\n"));

/***/ })

});